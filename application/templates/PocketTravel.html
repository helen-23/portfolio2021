{% extends "projects_base.html" %}

{% block project_image %}
{% load static %}
    <img class="project-intro-img" src="{% static 'images/PocketTravel/Logo.png' %}" alt="">
    <h2>A Geographical Information System (GIS) Application</h2>
{% endblock %}

<nav id="navbar-example3" class="navbar navbar-light bg-light">
    <a class="navbar-brand" href="#">Navbar</a>
    <nav class="nav nav-pills flex-column">
      <a class="nav-link" href="#item-1">Item 1</a>
      <nav class="nav nav-pills flex-column">
        <a class="nav-link ml-3 my-1" href="#item-1-1">Item 1-1</a>
        <a class="nav-link ml-3 my-1" href="#item-1-2">Item 1-2</a>
      </nav>
      <a class="nav-link" href="#item-2">Item2</a>
      <a class="nav-link" href="#item-3">Item3</a>
      <nav class="nav nav-pills flex-column">
        <a class="nav-link ml-3 my-1" href="#item-3-1">Item 3-1</a>
        <a class="nav-link ml-3 my-1" href="#item-3-2">Item 3-2</a>
      </nav>
    </nav>
  </nav>

{% block sidebar_content %}
{% load static %}
    <li class="nav-item active">
        <a class="nav-link" href="#intro-section">Introduction</a>
    </li>
    <nav class="nav nav-pills flex-column">
        <li class="nav-item">
            <a class="nav-link ml-3 my-1" href="#prob-subsection">Problem</a>
        </li>
        <li class="nav-item">
            <a class="nav-link ml-3 my-1" href="#solution-subsection">Our Solution</a>
        </li>
    </nav>
    <li class="nav-item">
        <a class="nav-link" href="#design-section">Design</a>
    </li>
    <nav class="nav nav-pills flex-column">
        <li class="nav-item">
            <a class="nav-link ml-3 my-1" href="#features-subsection">Features</a>
        </li>
        <li class="nav-item">
            <a class="nav-link ml-3 my-1" href="#algo-subsection">Algorithms</a>
        </li>
        <li class="nav-item">
            <a class="nav-link ml-3 my-1" href="#contrib-subsection">My Contributions</a>
        </li>
    </nav>
{% endblock %}

{% block project_content %}
{% load static %}
    <div class="card text-center mx-auto team-info-card">
        <div class="card-body">
            <p><b>Team Members:</b> Helen Dai, Vicky Liu, Verna Tian </p>
            <p><b>Duration:</b> Jan 2018 - Apr 2018 (4 months) </p>
            <p><b>Skills/Tools:</b> C++, EzGL </p>
            <p><b>My Role:</b> UI Design, Algorithm Research/Implementation </p>
        </div>
    </div>

    <!-- Intro -->
    <section class="main-section" id="intro-section">
        <h1>Introduction</h1>
        <!-- Problem -->
        <section class="sub-section" id="prob-subsection">
            <h4>Problem</h4>
            <p>Our inspiration comes from the observation of confused-looking backpackers trying to find their way in Union Station everyday. Most of them come from other cities for an adventure and must rely on the subway system to get from place to place. <mark>Physical maps often get outdated and they are a hassle to carry around, especially if these backpackers have multiple destinations on their plan. On the other hand, a digital map often require access to a data plan</mark>, which is unreasonable if the backpackers are staying at a forign city for only a few days. In addition, patchy internet connections in the wild (such as hicking trails) can lead to laggy digital maps. This is a common issue people face when they are travelling in another city, so how can we resolve it?</p>
        </section>
        <!-- Solution -->
        <section class="sub-section" id="solution-subsection">
            <h4>Our Solution</h4>
            <p>Our team presents PocketTravel, <mark>a fast mapping software that provides detialed offline maps for travelling backpackers</mark>. The current prototype is implemented as a desktop application, but ultimately we would like this to work on a hand-held device as well. All databases used to build this application were provided by the ECE department at the University of Toronto.</p>
        </section>
    </section>

    <!-- Design -->
    <section class="main-section" id="design-section">
        <h1>Design</h1>
        <!-- Features -->
        <section class="sub-section" id="features-subsection">
            <h4>Features</h4>
            <div class="row section-element">
                <div class="col-lg-6 my-auto">
                    <div class="page">
                        <div class="titlebar">
                            <div class="dot closes"></div><div class="dot minimise"></div><div class="dot maximise"></div><div class="location">Toronto, Canada</div>
                        </div>
                        <img src="{% static 'images/PocketTravel/levels_of_details.png' %}" alt="subpage item">
                    </div>
                </div>
                <div class="col-lg-6 my-auto vertical-center">
                    <p><b>1. Levels of Detail</b><br>A typical city contains thousands of features, but showing all of them can be overwhelming and slow to render. From observations and experiences, <mark>users typically use the map for different purposes at different zoom levels</mark>. At lower levels, users can collect large scale data, such as the coverage of large lakes. Zooming in, users can see highways and major streets to plan out long-distance routes. Zooming in further, PocketTravel starts drawing all the streets and buildings in between. Because we are following this <mark>user psychology</mark>, we have made the map more efficient and predictable for users while navigating through it.</p>    
                </div>
            </div>
            <div class="row section-element">
                <div class="col-lg-6 my-auto vertical-center">
                    <p><b>2. Library of Maps</b><br>PocketTravel supports maps of <mark>19 major cities from countries worldwide</mark>. From the side bar, users can click on “change maps” to summon up a window with a list of those cities. When the desired city is selected, the corresponding map will automatically launch up. We have chosen to keep the graphics interface at a minimal for efficiency and ease of use. Typical cities are loaded within 2 seconds and more complex ones, such as Tokyo, can be loaded within 30 seconds. </p>
                </div>
                <div class="col-lg-6 my-auto">
                    <div class="page">
                        <div class="titlebar">
                            <div class="dot closes"></div><div class="dot minimise"></div><div class="dot maximise"></div><div class="location" id="location">Toronto, Canada</div>
                        </div>
                        <img src="{% static 'images/PocketTravel/change_map.gif' %}" alt="subpage item">
                    </div>
                </div>
            </div>
            <div class="row section-element">
                <div class="col-lg-6 my-auto">
                    <div class="page">
                        <div class="titlebar">
                            <div class="dot closes"></div><div class="dot minimise"></div><div class="dot maximise"></div><div class="location">Toronto, Canada</div>
                        </div>
                        <img src="{% static 'images/PocketTravel/autocomplete.gif' %}" alt="subpage item">
                    </div>
                </div>
                <div class="col-lg-6 my-auto vertical-center">
                    <p><b>3. Search Bar with Auto Complete</b><br>The search bar is by default hidden so that the screen usage can be maximized, but it can be summoned upon toggling the "Find" button. Users can use it to search the intersection of two different streets, then PocketTravel will quickly locate it on the map (it will <mark>zoom in and highlight the intersection of interest</mark>). We have also implemented the autocomplete feature for convenience.</p>
                </div>
            </div>
            <div class="row section-element">
                <div class="col-lg-6 my-auto vertical-center">
                    <p><b>4. Search History</b><br>Each time after an intersection is looked up, the search history will be recorded for users to recall at a later time.</p>
                </div>
                <div class="col-lg-6 my-auto">
                    <div class="page">
                        <div class="titlebar">
                            <div class="dot closes"></div><div class="dot minimise"></div><div class="dot maximise"></div><div class="location">Toronto, Canada</div>
                        </div>
                        <img src="{% static 'images/PocketTravel/search_history.gif' %}" alt="subpage item">
                    </div>
                </div>
            </div>
            <p><b>5. Best Route Planning</b></p>
            <p>PocketTravel can calculate the best route between two intersections and provide the directions. This can be done in 3 ways: <mark>by selecting two points on the map, searching the two intersections, or a combination of both</mark>. The shortest route will be highlighted and users can see step-by-step instructions in words at the bottom of the screen. Users can also click on multiple points on the map for a <mark>multi-stop route planning</mark>.</p>
            <div class="row section-element">
                <div class="col-lg-6 my-auto">
                    <div class="page">
                        <div class="titlebar">
                            <div class="dot closes"></div><div class="dot minimise"></div><div class="dot maximise"></div><div class="location">Toronto, Canada</div>
                        </div>
                        <img src="{% static 'images/PocketTravel/direction_search.gif' %}" alt="subpage item">
                    </div>
                </div>
                <div class="col-lg-6 my-auto">
                    <div class="page">
                        <div class="titlebar">
                            <div class="dot closes"></div><div class="dot minimise"></div><div class="dot maximise"></div><div class="location">Toronto, Canada</div>
                        </div>
                        <img src="{% static 'images/PocketTravel/directions_click.gif' %}" alt="subpage item">
                    </div>
                </div>
            </div>
            <p><b>6. Points of Interest (POI)</b><br>We use different colors to represent different types of POIs. When hovering over a POI, users are able to see its name on screen. These features help backpackers to find specific venues easier.</p>
            <div class="page" style="width: 60%; margin: 20px auto;">
                <div class="titlebar">
                    <div class="dot closes"></div><div class="dot minimise"></div><div class="dot maximise"></div><div class="location">Toronto, Canada</div>
                </div>
                <img src="{% static 'images/PocketTravel/hover_mouse.gif' %}" alt="subpage item">
            </div>
            <p><b>7. Subway Lines and Stations</b></p>
            <p>By clicking the "Show Subway" button, subway lines will show up on the map. Different lines are in different colors, and when zoomed in to a certain level, small icons become visible to indicate the location of each subway station.</p>
            <div class="row section-element">
                <div class="col-lg-6 my-auto">
                    <div class="page">
                        <div class="titlebar">
                            <div class="dot closes"></div><div class="dot minimise"></div><div class="dot maximise"></div><div class="location">Tokyo, Japan</div>
                        </div>
                        <img src="{% static 'images/PocketTravel/subway.jpg' %}" alt="subpage item">
                    </div>
                </div>
                <div class="col-lg-6 my-auto">
                    <div class="page">
                        <div class="titlebar">
                            <div class="dot closes"></div><div class="dot minimise"></div><div class="dot maximise"></div><div class="location">Toronto, Canada</div>
                        </div>
                        <img src="{% static 'images/PocketTravel/subway_icons.jpg' %}" alt="subpage item">
                    </div>
                </div>
            </div>
        </section>

        <!-- Algorithms -->
        <section class="sub-section" id="algo-subsection">
            <h4>Algorithms</h4>
            <p><b>Nearest Intersection: K-D Tree</b></p>
            <p>Our algorithm snaps the user’s mouse input coordinates to the nearest intersection by using a k-d Tree, which <mark>divides the intersections into sections according to their x and y coordinates, alternately simplifying the search by avoiding points that are unworthy in visiting</mark>. The following steps are used to build the tree:</p>
            <ol>
                <li class="list">pick the point in the middle of the horizontal axis (shown in red), set it as the head node</li>
                <li class="list">nodes on the left branch of the head node correspond to the points on the left side of the red line and nodes on the right branch correspond to the right side</li>
                <li class="list">from each side, we pick the point in the middle of the vertical axis and add them as the child node of the head node</li>
                <li class="list">repeat this with alternating vertical and horizontal divisions until all the nodes have been placed on the tree and the map has been divided into sections</li>
            </ol>
            <p>A naïve way to find the nearest intersection would be to loop through all the intersections and compare them against the intersection of interest, which is very slow. For a k-d tree, we can simplify this process. To find the nearest intersection from the tree, steps are as follows:</p>
            <ol>
                <li class="list">given a point, traverse through the k-d tree by alternating the comparison between its x coordinate to a node’s x coordinate and its y coordinate to a node’s y coordinate (i.e. compare the point’s x coordinate with the head node, then compare the point’s y coordinate with the y coordinate of one of the nodes in the next level, and so on)</li>
                <li class="list">once arrived at a leaf node, first calculate the Euclidean distance between the given point and the leaf node, then for this particular example below, get the leaf node’s parent node and calculate the distance between the given point and the horizontal line that passes through the parent node. If the distance to the leaf node is shorter than the distance to the line, then there is no need to check the node on the other side of  the parent node</li>
            </ol>
            <p>That's how the k-d tree avoids the points that are unworthy of visiting. As shown on the graph, <mark>the naïve search algorithm becomes slower as more points are being searched, but using k-d Tree, this algorithm does slow down as drastically</mark>, instead, it stays at around 0.</p>
            <figure class="figure_container">
                <img src="{% static 'images/PocketTravel/kd_tree.gif' %}" alt="subpage item">
                <img src="{% static 'images/PocketTravel/kd_tree_improvement.png' %}" alt="subpage item">
            </figure>
            <p><b>Auto Complete: Trie Tree</b></p>
            <p>We have chosen to use the trie tree because it <mark>produces a time complexity of O(n) at runtime</mark>. The tree only had to be built once: the first level of the tree is the first letter of the street names, from A to Z, the second level is the second letter, and so on. A continuous path to the end in the tree is a full street name. There is a flag in each node to indicate if it is the end of the word.</p>
            <figure class="figure_container">
                <img src="{% static 'images/PocketTravel/trie.gif' %}" alt="subpage item">
            </figure>
            <p><b>Best Route Planning (Travelling Salesman Problem): Dijkstra’s vs A*</b></p>
            <p>
                To find the cheapest path between two intersections, we used the A* algorithm, which is similar to the Dijkstra's algorithm, but uses heuristics to find the solutions faster.<br><br>
                For Dijkstra's, we would first set the score of the source to 0, and others to infinity, labeling the scores as f(n). We would then update the score of every adjacent point of the source point to the cost of the cheapest path traveling from the source point, and push the adjacent points to a priority queue. When choosing the next point to visit from the priority queue, we would always visit the point with lowest f(n), and the process goes on until we reach the destination. A demonstration of the algorithm is shown below.<br><br>
                <mark>How A* differs from Dijkstra's is that when it chooses the next point to visit from the priority queue, instead of choosing the point with the lowest cost, g(n), it also takes a heuristic factor, h(n), into consideration</mark>. That is, the heuristic that estimate the cost of the cheapest path from the point to the destination, which may result in choosing a point that is not the cheapest to go to for that segment, but will ultimately lead to the optimal destination faster.<br><br>
                The image on the right compares the visited nodes for the A* algorithm and for the Dijkstra's algorithm. The yellow path is the path we found, and the purple points are the nodes we visit during the search. It is obvious that <mark>the number of points A* visited is much less than that of Dijkstra's</mark> (a spread-out circular region vs a more directed oval region). This means that A* significantly speeds up the path the searching process.
            </p>
            <figure class="figure_container">
                <img src="{% static 'images/PocketTravel/dijkstra.gif' %}" alt="subpage item">
                <img src="{% static 'images/PocketTravel/dijkstra_vs_astar.jpg' %}" alt="subpage item">
            </figure>
            <p><b>Multi-Destination Planning: Greedy, Two-Opt, and Simulated Annealing</b></p>
            <p>
                For multi-destination planning, we first used the greedy algorithm, where we chose a random starting point and then fetch the nearest destination as the next point to visit until we visit all the destinations. However, the paths that greedy found are not good enough because it always gets stuck at a local minimum, so we wanted to <mark>find a way to jump out of local minimum and eventually reach the global minimum</mark>.<br><br>
                Once an “optimal” path is found from greedy, using 2-opt, we cut the path into 3 pieces and then we reconnect the three path segments. We created <mark>12 different types of recombination in total. In addition to this, we also implemented simulated annealing</mark>. At first the temperature is high, and it will accept the solution in a large range, so the possibility of getting a worse solution than the local minimum is high. However, the temperature will adjust and decrease over time ,so that it will gradually narrow down to near where the global minimum is. <mark>This resulted in an average of 8196 seconds traveling time decrease for the paths found</mark>.
            </p>
            <figure class="figure_container">
                <img src="{% static 'images/PocketTravel/greedy.gif' %}" alt="subpage item">
                <img src="{% static 'images/PocketTravel/2opt.gif' %}" alt="subpage item">
                <img src="{% static 'images/PocketTravel/annealing.PNG' %}" alt="subpage item">
            </figure>
            <p><br>To further optimize for the final competition, we chose to implement multi-start with multithread. Since we were running on a 8-core processor for the competition portion of this project, we decided to <mark>choose the best 8 solutions obtained from the greedy search, loop through each as a candidate starting point on a separate thread, then so two-opt and simulated annealing simultaneously on each candidate. We ended up with an additional improvement of 4422 seconds decrease in average traveling time</mark>.</p>
            <figure class="figure_container">
                <img src="{% static 'images/PocketTravel/multithread.PNG' %}" alt="subpage item">
                <img src="{% static 'images/PocketTravel/multithread_improvement.png' %}" alt="subpage item">
            </figure>
        </section>
    </section>

    <section class="main-section" id="contrib-subsection">
        <h1>My Contributions</h1>
    </section>

    <script>
        $(function () { 
        count = 0; 
        wordsArray = ["Toronto, Canada", "Toronto, Canada", "Toronto, Canada", "Beijing, China", "Beijing, China"]; 
        setInterval(function () { 
            count++; 
            $("#location").fadeOut(0, function () { 
                $(this).text(wordsArray[count % wordsArray.length]).fadeIn(0); 
            }); 
        }, 1460); 
    });
    </script>
        
{% endblock %}